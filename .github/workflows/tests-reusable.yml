name: tests-reusable

on:
  workflow_call:
    inputs:
      runs-on:
        description: 'The type of machine to run the job on'
        required: false
        default: 'macos-12'
        type: string
      testsScheme:
        required: true
        type: string # 'XXXUnitTests', 'XXXSnapshots' or whatever
      testsKind:
        required: true
        type: string # 'UnitTests' or 'Snapshots'
      testsName:
        required: true
        type: string # 'Unit Tests', 'Snapshots' or whatever
    outputs:
      tests-passed:
        description: "Tests passed"
        value: ${{ jobs.tests.outputs.tests-passed }}
    secrets:
      APP_STORE_AUTHENTICATION_KEY_BASE64:
        required: true
      APP_STORE_AUTHENTICATION_KEY_ID:
        required: true
      APP_STORE_AUTHENTICATION_KEY_ISSUER_ID:
        required: true
      KEYCHAIN_PASSWORD:
        required: true
      P12_PASSWORD:
        required: true
      APPLE_WWDR_CERTIFICATION_AUTHORITY_CER_BASE64:
        required: true
      BUILD_CERTIFICATE_BASE64:
        required: true
      EXPORT_CERTIFICATE_DEVELOPER_ID_BASE64:
        required: true

defaults:
  run:
    shell: bash --noprofile --norc -x -euo pipefail {0}

jobs:
  tests:
    name: Run ${{ inputs.testsName }}
    runs-on: ${{ fromJSON(inputs.runs-on) }}    

    outputs:
      tests-passed: ${{ steps.run-tests.outputs.tests-failed != 'true' && steps.run-tests.conclusion == 'success' }}

    env:
      PROJECT_KIND: 'DeveloperID'
      RUN_STAMP: ${{ github.run_id }}.${{ github.run_attempt }}
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      KEYCHAIN_NAME: app-signing.keychain-db
      TESTS_SCHEME: ${{ inputs.testsScheme }}
      TESTS_NAME: ${{ inputs.testsName }}
      TESTING_SNAPSHOTS: ${{ inputs.testsKind == 'Snapshots' }}

    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
          submodules: true

      - name: Dump Environment
        run: |
          launchctl managername
          automationmodetool
          env | sort
          git --no-pager log -10 --pretty=format:"%h %ad %an %s"

      - name: Setup Environment
        run: |
          echo "DERIVED_DATA_PATH=$PWD/tmp/build.derivedData" >> $GITHUB_ENV
          echo "XCRESULTS_DIRECTORY=$RUNNER_TEMP" >> $GITHUB_ENV
          echo "TEST_PRODUCTS_DIRECTORY=$RUNNER_TEMP" >> $GITHUB_ENV
          echo "REGENERATED_SNAPSHOTS_ARCHIVE=$RUNNER_TEMP/Regenerated-Snapshots.${{ env.RUN_STAMP }}.tar.gz" >> $GITHUB_ENV
          echo "RW_GHA_CHECK_PRIVATE_KEY_SECRET_NAME=${{ format('RW_GHA_CHECK_{0}_PRIVATE_KEY', inputs.testsKind) }}" >> $GITHUB_ENV
          echo "RW_GHA_CHECK_APP_ID_SECRET_NAME=${{ format('RW_GHA_CHECK_{0}_APP_ID', inputs.testsKind) }}" >> $GITHUB_ENV
          echo "UPDATED_SNAPSHOTS_BRANCH=${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}-Updated-Snapshots-For-$TESTS_SCHEME" >> $GITHUB_ENV

      - uses: maxim-lobanov/setup-xcode@v1.5.1
        with:
          xcode-version: 'latest'

      - name: Install Dependencies
        run: |
          ./GHAShortcuts/InstallDependencies
          ./GHAShortcuts/InstallDependencies-tests

      - name: Cache Mint packages
        id: mint-cache
        uses: actions/cache@v3
        with:
          path: ~/.mint
          key: ${{ runner.os }}-${{ runner.temp }}-mint-${{ hashFiles('**/Mintfile') }}
          restore-keys: ${{ runner.os }}-${{ runner.temp }}-mint-

      - name: Install Mint packages
        if: steps.mint-cache.outputs.cache-hit != 'true'
        run: mint bootstrap

      - name: Create Keychain
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # create variables
          KEYCHAIN_PATH="$RUNNER_TEMP"/"$KEYCHAIN_NAME"

          # create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security list-keychain

      - name: Install certificates
        env:
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          APPLE_WWDR_CERTIFICATION_AUTHORITY_CER_BASE64: ${{ secrets.APPLE_WWDR_CERTIFICATION_AUTHORITY_CER_BASE64 }}
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          EXPORT_CERTIFICATE_BASE64: ${{ secrets.EXPORT_CERTIFICATE_BASE64 }}
          EXPORT_CERTIFICATE_DEVELOPER_ID_BASE64: ${{ secrets.EXPORT_CERTIFICATE_DEVELOPER_ID_BASE64 }}
        run: |
          # create variables
          KEYCHAIN_PATH="$RUNNER_TEMP"/app-signing.keychain-db
          APPLE_WWDR_CERTIFICATION_AUTHORITY_CER_PATH="$RUNNER_TEMP"/apple_wwdr_ca.cer
          BUILD_CERTIFICATE_PATH="$RUNNER_TEMP"/build_certificate.p12
          EXPORT_CERTIFICATE_PATH="$RUNNER_TEMP"/export_certificate.p12
          EXPORT_CERTIFICATE_DEVELOPER_ID_PATH="$RUNNER_TEMP"/export_certificate_developer_id.p12

          # import certificate from secrets
          echo -n "$APPLE_WWDR_CERTIFICATION_AUTHORITY_CER_BASE64" | base64 --decode -o "$APPLE_WWDR_CERTIFICATION_AUTHORITY_CER_PATH"
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o "$BUILD_CERTIFICATE_PATH"
          echo -n "$EXPORT_CERTIFICATE_BASE64" | base64 --decode -o "$EXPORT_CERTIFICATE_PATH"
          echo -n "$EXPORT_CERTIFICATE_DEVELOPER_ID_BASE64" | base64 --decode -o "$EXPORT_CERTIFICATE_DEVELOPER_ID_PATH"

          # import certificate to keychain
          security import "$APPLE_WWDR_CERTIFICATION_AUTHORITY_CER_PATH" -k "$KEYCHAIN_PATH"
          security import "$BUILD_CERTIFICATE_PATH" -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security import "$EXPORT_CERTIFICATE_PATH" -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security import "$EXPORT_CERTIFICATE_DEVELOPER_ID_PATH" -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

      - name: Erase profiles remaining from previous builds
        run: |
          rm -rf ~/Library/MobileDevice/Provisioning\ Profiles

      - uses: actions/cache@v3
        if: ${{ false }}
        with:
          path: ${{ env.DERIVED_DATA_PATH }}/SourcePackages
          key: ${{ runner.os }}-spm-${{ hashFiles('*.xcodeproj/**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      - name: Generate Project
        run: |
          ./Commands/GenerateProject "$PROJECT_KIND"

      - name: Build for testing
        id: build-for-testing
        run: |
          BUILD_XCRESULT="$XCRESULTS_DIRECTORY"/"$TESTS_SCHEME"-build.xcresult
          echo "BUILD_XCRESULT=$BUILD_XCRESULT" >> $GITHUB_ENV
          TEST_PRODUCTS_PATH="$TEST_PRODUCTS_DIRECTORY/${{ inputs.testsScheme }}.xctestproducts"
          echo "TEST_PRODUCTS_PATH=$TEST_PRODUCTS_PATH" >> $GITHUB_ENV

          exit_code=0
          ./ReusableWorkflows/GHAScripts/XcodebuildBuildForTesting \
            -derivedDataPath "$DERIVED_DATA_PATH" \
            -scheme "$TESTS_SCHEME" \
            -resultBundlePath "$BUILD_XCRESULT" \
            -testProductsPath "$TEST_PRODUCTS_PATH" \
            | exit_code=$?

          echo "exit-code=$exit_code" >> $GITHUB_OUTPUT

          # Save .xcresult even in case of failure.
          ./GHAScripts/gh-tar "$(dirname "$BUILD_XCRESULT")" "$BUILD_XCRESULT"

      - name: Save build.xcresult
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.TESTS_SCHEME }}-build-xcresult
          if-no-files-found: error
          path: |
            ${{ env.BUILD_XCRESULT }}.tar
    
      - name: Exit on build failure
        if: ${{ steps.build-for-testing.outputs.exit-code != '0' }}
        run: |
          exit ${{ steps.build-for-testing.outputs.exit-code }}
    
      - name: Run Tests
        id: run-tests
        run: |
          TESTS_XCRESULT="$XCRESULTS_DIRECTORY"/"$TESTS_SCHEME"-tests.xcresult
          echo "TESTS_XCRESULT=$TESTS_XCRESULT" >> $GITHUB_ENV

          if $TESTING_SNAPSHOTS; then
            stamp=$(mktemp /tmp/RegenerateSnapshots.XXXXXX)
            export TEST_RUNNER_SNAPSHOT_RECORDING=YES # Should have effect on RunTests
            export TEST_RUNNER_SNAPSHOT_SKIP_DIFF_MESSAGE=YES # Make failure reports less verbose.
          fi

          echo "::group::Run xcodebuild test"
          exit_code=0
          ./ReusableWorkflows/GHAScripts/XcodebuildTestWithoutBuilding \
            -destination 'platform=macOS' \
            -derivedDataPath "$DERIVED_DATA_PATH" \
            -resultBundlePath "$TESTS_XCRESULT" \
            -testProductsPath "$TEST_PRODUCTS_PATH" \
            || exit_code=$?
          echo "::endgroup::"

          # Save .xcresult even in case of failure.
          ./GHAScripts/gh-tar "$(dirname "$TESTS_XCRESULT")" "$TESTS_XCRESULT"
          
          echo "exit-code=$exit_code" >> "$GITHUB_OUTPUT"

          if [ "$exit_code" -ne 65 ] && [ "$exit_code" -ne 0 ]; then
            echo "malfunction=true" >> $GITHUB_OUTPUT
            echo "exit-code=$exit_code" >> $GITHUB_OUTPUT
            exit
          fi

          if [ "$exit_code" == "65" ]; then
            echo "tests-failed=true" >> $GITHUB_OUTPUT
            echo "::error title=$TESTS_SCHEME did fail::See ${{ env.TESTS_NAME }} Results for more info."
          fi

          if $TESTING_SNAPSHOTS; then
            save_x() {
              if [[ $- = *x* ]]; then
                echo 'set -x'
              else
                echo 'set +x'
              fi
            }
            generated() {
              restore_x=$(save_x); set +x
              TESTS_SCHEME="$TESTS_SCHEME" GHAShortcuts/ListSnapshots | while read file; do
                if [ "$file" -nt "$stamp" ]; then
                  echo "$file"
                fi
              done
              $restore_x
            }
            obsolete() {
              restore_x=$(save_x); set +x
              TESTS_SCHEME="$TESTS_SCHEME" GHAShortcuts/ListSnapshots | while read file; do
                if [ "$file" -ot "$stamp" ]; then
                  echo "$file"
                fi
              done
              $restore_x
            }
            generated_count=$(generated | wc -l | sed 's/^ *//')
            obsolete_count=$(obsolete | wc -l | sed 's/^ *//')
            echo "generated_count=$generated_count" >> $GITHUB_OUTPUT
            echo "obsolete_count=$obsolete_count" >> $GITHUB_OUTPUT
            if [ "$generated_count" == 0 ]; then
              echo "::error title=No snapshots were generated via $TESTS_SCHEME::There're no snapshots generated; something is likely wrong."
              echo "malfunction=true" >> $GITHUB_OUTPUT
              exit
            fi
            if [ "$obsolete_count" -gt 0 ]; then
              echo "tests-failed=true" >> $GITHUB_OUTPUT # Treat obsolete snapshots as test failures.
            fi
            obsolete | tr '\n' '\0' | xargs -0 rm
            generated | tr '\n' '\0' | xargs -0 tar czf "$REGENERATED_SNAPSHOTS_ARCHIVE"
          fi

      - name: Delete the previous version of snapshots branch
        if: ${{ env.TESTING_SNAPSHOTS == 'true' && steps.run-tests.outputs.malfunction != 'true' }}
        run: |
          if git fetch origin ${{ env.UPDATED_SNAPSHOTS_BRANCH }} 2>/dev/null; then
            git push origin --delete ${{ env.UPDATED_SNAPSHOTS_BRANCH }}
          fi

      - name: Stash the snapshot changes, if exercising a PR
        if: ${{ env.TESTING_SNAPSHOTS == 'true' && steps.run-tests.outputs.malfunction != 'true' && github.event_name == 'pull_request' }}
        run: |
          git stash

      - name: Prepare for creation of regenerated snapshot branch, if exercising a PR
        uses: actions/checkout@v3
        if: ${{ env.TESTING_SNAPSHOTS == 'true' && steps.run-tests.outputs.malfunction != 'true' && github.event_name == 'pull_request' }}
        with:
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Unstash the snapshot changes, if exercising a PR
        if: ${{ env.TESTING_SNAPSHOTS == 'true' && steps.run-tests.outputs.malfunction != 'true' && github.event_name == 'pull_request' }}
        run: |
          git stash pop

      - name: Create Branch for Snapshots
        id: snapshot-branch
        if: ${{ env.TESTING_SNAPSHOTS == 'true' && steps.run-tests.outputs.malfunction != 'true' }}
        run: |
          git checkout -b "$UPDATED_SNAPSHOTS_BRANCH"
          git add *.png
          if git commit -m "Updated snapshots via $TESTS_SCHEME."; then
            echo "committed=true" >> $GITHUB_OUTPUT
            git push --force --set-upstream origin "$UPDATED_SNAPSHOTS_BRANCH"
          fi

      - name: Add a note about updated snapshots branch (or lack of it)
        if: ${{ env.TESTING_SNAPSHOTS == 'true' }}
        run: |
          committed=${{ steps.snapshot-branch.outputs.committed }}
          if [ "$committed" == 'true' ]
          then
            verbalize_git_name_status() {
              #
              # Turns something like this:
              # ```
              # M    foo
              # D    bar
              # M    baz
              # ```
              # Into this: `1 deleted, 2 modified`
              #

              cut -f 1 `# cut first letter` |
                sort `# prepare for uniq` |
                sed -e 's/^A$/added/' -e 's/M/modified/' -e 's/D/deleted/' `# M -> modified, etc.` |
                uniq -c `# count and compress them` |
                sed 's/^ *//' `# drop initial spacing enforced by uniq` |
                sed 's/$/,/' `# add comma to the end of line` |
                tr '\n' ' ' `# join lines` |
                sed 's/, $//' `# drop last comma and space`
          
              echo # Make it line-terminated
            }
            stats=$(git diff HEAD^..HEAD --name-status | verbalize_git_name_status)
            echo "::error title=Snapshots in $TESTS_SCHEME are not up to date::Among ${{ steps.run-tests.outputs.generated_count }} generated snapshots: $stats. Changes are pushed to ${{ env.UPDATED_SNAPSHOTS_BRANCH }}."
          else
            echo "::error title=No changes in $TESTS_SCHEME::${{ steps.run-tests.outputs.generated_count }} snashots were regenerated without a change."
          fi
  
      # https://github.com/orgs/community/discussions/24616#discussioncomment-5607870
      - name: Retrieve Token For Generating Test Results
        if: ${{ false }}
        id: gha_check_app_token
        uses: tibdex/github-app-token@v1.8.0
        env:
          OPENSSL_CONF: /dev/null  # https://github.com/tibdex/github-app-token/issues/54
        with:
          app_id: ${{ secrets[env.RW_GHA_CHECK_APP_ID_SECRET_NAME] }}
          private_key: ${{ secrets[env.RW_GHA_CHECK_PRIVATE_KEY_SECRET_NAME] }}

      - name: Check Test Results
        uses: kishikawakatsumi/xcresulttool@v1.7.1
        with:
          path: ${{ env.TESTS_XCRESULT }}
          title: "${{ env.TESTS_NAME }} Results"
          upload-bundles: never
          show-passed-tests: false
          # token: ${{ steps.gha_check_app_token.outputs.token }} # https://github.com/orgs/community/discussions/24616#discussioncomment-5607870

      - name: Exit on Tests Malfunction
        if: ${{ steps.run-tests.outputs.malfunction == 'true' }}
        run: |
          exit ${{ steps.run-tests.outputs.exit-code }}

      - name: Save .xcresult
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.TESTS_SCHEME }}-tests-xcresult
          if-no-files-found: error
          path: |
            ${{ env.TESTS_XCRESULT }}.tar

      - name: Save Regenerated Snapshots
        if: ${{ env.TESTING_SNAPSHOTS == 'true' }}
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.TESTS_SCHEME }}-Regenerated
          if-no-files-found: error
          path: |
            ${{ env.REGENERATED_SNAPSHOTS_ARCHIVE }}
